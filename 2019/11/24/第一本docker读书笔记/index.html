<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="读书笔记 记录了一些实验和命令 容器链接等">
<meta name="keywords" content="读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="第一本docker读书笔记">
<meta property="og:url" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/index.html">
<meta property="og:site_name" content="Recar的笔记">
<meta property="og:description" content="读书笔记 记录了一些实验和命令 容器链接等">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/sudo_docker_info.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%9B%E7%A8%8B.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9Ccpu%E7%AD%89%E4%BF%A1%E6%81%AF.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/sudo_docker_history.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/docker_network_create.jpg">
<meta property="og:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/etc_hosts.jpg">
<meta property="og:updated_time" content="2021-06-11T10:33:06.389Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第一本docker读书笔记">
<meta name="twitter:description" content="读书笔记 记录了一些实验和命令 容器链接等">
<meta name="twitter:image" content="http://yoursite.com/2019/11/24/第一本docker读书笔记/sudo_docker_info.jpg">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/11/24/第一本docker读书笔记/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>第一本docker读书笔记 | Recar的笔记</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f6Wf4b00fa957d7290583a86b0d8c2de1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Recar的笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    
  
  

  

  <a href="https://github.com/Ciyfly" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/24/第一本docker读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Recar">
      <meta itemprop="description" content="年轻人就应该多读源码多读书">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Recar的笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第一本docker读书笔记

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 16:43:10" itemprop="dateCreated datePublished" datetime="2019-11-24T16:43:10+00:00">2019-11-24</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-06-11 10:33:06" itemprop="dateModified" datetime="2021-06-11T10:33:06+00:00">2021-06-11</time>
              </span>
            
          

          

          
          

          

          

          <br>
          

          

          
            <div class="post-description"><<第一本docker>> 读书笔记 记录了一些实验和命令 容器链接等</第一本docker></div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第一本docker"><a href="#第一本docker" class="headerlink" title="第一本docker"></a>第一本docker</h1><p>也是我读的第一本docker书 之前都是在网上看资料学习<br>因为是弥补我的docker知识空白处 所有总结内容更偏向我自己不熟悉的地方</p>
<p>docker是cs架构 分为服务端和客户端的 docker即是客户端也可以作为服务端<br>Registry 是镜像仓库  可以建立私服 公共服务叫 docker hub  </p>
<p>镜像是Docker生命周期中的构建和打包阶段 容器则是启动或执行阶段  </p>
<p>对于对系统的内核有版本要求的  </p>
<p>ubuntu下要linux内核3.8以上<br>之前就遇到过内核版本过低的问题<br>Red Hat需要内核大于3.8  </p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>书的内容老了 这里记录最新的<br>参考链接 <a href="https://blog.csdn.net/BingZhongDeHuoYan/article/details/79411479" target="_blank" rel="noopener">https://blog.csdn.net/BingZhongDeHuoYan/article/details/79411479</a></p>
<p>由于apt官方库里的docker版本可能比较旧，所以先卸载可能存在的旧版本：<br><code>$ sudo apt-get remove docker docker-engine docker-ce docker.io</code></p>
<p>更新apt包索引：<br><code>$ sudo apt-get update</code></p>
<p>安装以下包以使apt可以通过HTTPS使用存储库（repository）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span></span><br></pre></td></tr></table></figure>

<p>添加Docker官方的GPG密钥：<br><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></p>
<p>使用下面的命令来设置stable存储库：<br><code>$ sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</code></p>
<p>再更新一下apt包索引：<br><code>$ sudo apt-get update</code></p>
<p>安装最新版本的Docker CE：<br><code>$ sudo apt-get install -y docker-ce</code></p>
<p>在生产系统上，可能会需要应该安装一个特定版本的Docker CE，而不是总是使用最新版本：<br>列出可用的版本：</p>
<p><code>$ apt-cache madison docker-ce</code></p>
<p>查看当前docker信息<br><code>sudo docker info</code>  </p>
<p><img src="/2019/11/24/第一本docker读书笔记/sudo_docker_info.jpg" alt="sudo docker info"></p>
<h3 id="docker-与ufw"><a href="#docker-与ufw" class="headerlink" title="docker 与ufw"></a>docker 与ufw</h3><p>docker -p 的端口映射的实现，会忽略系统的 UFW 规则  </p>
<p>由于Docker实际上绕过UFW并直接更改iptables，因此容器可以绑定到端口。这意味着您设置的所有那些UFW规则将不适用于Docker容器。  </p>
<p>深入链接 <a href="https://www.techrepublic.com/article/how-to-fix-the-docker-and-ufw-security-flaw/" target="_blank" rel="noopener">https://www.techrepublic.com/article/how-to-fix-the-docker-and-ufw-security-flaw/</a>  </p>
<p>解决:<br>有一种方法可以解决此问题。返回到Docker服务器上的终端，并发出命令<br><code>sudo nano / etc / default / docker</code><br>并添加以下行：<br><code>DOCKER_OPTS =&quot;-iptables = false&quot;</code><br>保存并关闭该文件。使用命令sudo systemctl restart docker重启docker守护进程。现在，当您部署容器时，它将不再更改iptables，而将支持UFW</p>
<h3 id="docker-一键安装脚本"><a href="#docker-一键安装脚本" class="headerlink" title="docker 一键安装脚本"></a>docker 一键安装脚本</h3><p><code>curl https://get.docker.com/ | sudo sh</code></p>
<p>会自动安装依赖并且检测内核是否满足条件 最后安装Docker并启动  </p>
<p><strong>docker守护进程监听 /var/run/docker.socket</strong> 这个Unix套接字文件来获取客户端的Docker请求  </p>
<p>有个docker用户组 dokcer用户组中应该只能添加那些确实需要使用docker的用户和程序  </p>
<p>docker deamon -H 可以修改守护进程的监听端口<br>那么对应的客户端也需要指定修改的地址 可以设置环境变量来修改 <code>DOCKER_HOST=&quot;tcp&quot;//ip:port&quot;</code>  </p>
<p><strong>查看docker守护进程运行状态</strong>  </p>
<p><code>sudo service docker status</code>  </p>
<p>升级 docker可以直接 update后再次安装  </p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p><code>sudo docker run -it -d ubuntu /bin/bash</code>  </p>
<p>run是创建加运行<br>it 是启一个可交互的shell<br>-d 是后台运行<br>/bin/bash 成功后会运行 /bin/bash 也就是一个shell  </p>
<p>创建后运行这个 shell 当你 exit 退出的时候也就是这个命令执行完成了<br>所以容器会停止运行  只要这个shell一直在 那么就会一直运行  </p>
<h3 id="获取最后一个运行的容器-无论停止还是运行"><a href="#获取最后一个运行的容器-无论停止还是运行" class="headerlink" title="获取最后一个运行的容器 无论停止还是运行"></a>获取最后一个运行的容器 无论停止还是运行</h3><p><code>sudo docker ps -l</code></p>
<h3 id="attach命令是附着到容器的会话上"><a href="#attach命令是附着到容器的会话上" class="headerlink" title="attach命令是附着到容器的会话上"></a>attach命令是附着到容器的会话上</h3><p>也就是还是那个执行的命令  </p>
<h3 id="获取容器的日志"><a href="#获取容器的日志" class="headerlink" title="获取容器的日志"></a><strong>获取容器的日志</strong></h3><p><code>sudo docker logs 容器</code>  </p>
<p>如果那个是个shell 那么就可以看到交互的输出的信息<br>加上 -t可以加上日志的时间<br>加上 -f 就跟 tail -f一样会持续输出了<br>还可以将日志输出到syslog</p>
<p>但是设置后 docker logs就不会有任何输出了  </p>
<h3 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h3><p><code>sudo docker top 容器</code></p>
<p><img src="/2019/11/24/第一本docker读书笔记/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%9B%E7%A8%8B.jpg" alt="查看容器内进程"></p>
<h3 id="查看容器cpu内容io等实时信息"><a href="#查看容器cpu内容io等实时信息" class="headerlink" title="查看容器cpu内容io等实时信息"></a>查看容器cpu内容io等实时信息</h3><p><code>sudo docker stats 容器/ 空的就所有容器</code></p>
<p><img src="/2019/11/24/第一本docker读书笔记/%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9Ccpu%E7%AD%89%E4%BF%A1%E6%81%AF.jpg" alt="查看容器网络cpu等信息"></p>
<h3 id="在容器中运行后台任务"><a href="#在容器中运行后台任务" class="headerlink" title="在容器中运行后台任务"></a>在容器中运行后台任务</h3><p><code>sudo docker exec -d 容器 命令</code><br>我们的再启一个shell 也是这样的进入容器<br><code>sudo docker exec -it 容器 /bin/bash</code></p>
<h3 id="查看最后x个容器"><a href="#查看最后x个容器" class="headerlink" title="查看最后x个容器"></a>查看最后x个容器</h3><p>无论运行还是停止<br><code>sudo docker ps -n x</code></p>
<h3 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h3><p>使用 <code>--restart</code><br><code>sudo docker run --restart=always --name test -d ubuntu /bin/bash</code>  </p>
<p>restart 设置为 always 即 无论容器的退出代码是什么都会重启容器<br>如果设置为 <code>on-failure</code> 这样只有当容器的退出码为非0的时候才会自动重启  </p>
<p>并且还可设置重启次数  </p>
<p><code>--restart=on-failure:5</code></p>
<h3 id="获取容器更多的信息"><a href="#获取容器更多的信息" class="headerlink" title="获取容器更多的信息"></a>获取容器更多的信息</h3><p><code>sudo docker insect 容器</code></p>
<h3 id="获取容器运行状态"><a href="#获取容器运行状态" class="headerlink" title="获取容器运行状态"></a>获取容器运行状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo docker inspect --format=<span class="string">'&#123;&#123;.State.Running&#125;&#125;'</span> 容器</span></span><br><span class="line">```  </span><br><span class="line">返回true/false  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 获取容器ip地址</span></span></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo docker inspect --format=<span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> 容器</span></span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>sudo docker rm 容器</code></p>
<p>再新启动一个容器的时候因为name的重复所以需要把之前重名的进行删除  </p>
<h3 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h3><p>sudo docker rm <code>sudo docker ps -a -q</code>  </p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>一个镜像可以位于一个镜像的上方<br>就相当于一层一层的往上叠加这个镜像<br>基于一个初始的镜像进行增加修改  </p>
<p>如果想修改一个文件 这个文件首先会从该读写层下面的只读层复制到该读写层<br>该文件的只读版本依然存在 但是已经被读写层中的该文件副本所隐藏<br>也就是说修改当前层的文件是是从底部复制过来一份进行修改并且只存在于当前层  </p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p><code>sudo docker pull ubuntu:12.04</code></p>
<p>12.04是标签 同一个仓库的不同镜像</p>
<h3 id="查看当前镜像"><a href="#查看当前镜像" class="headerlink" title="查看当前镜像"></a>查看当前镜像</h3><p><code>sudo docker 第一本docker读书笔记</code></p>
<h3 id="用户仓库"><a href="#用户仓库" class="headerlink" title="用户仓库"></a>用户仓库</h3><p>用户仓库的命名由用户和仓库名两部分组成<br>像github一样<br>即 <code>用户名/仓库名</code>  </p>
<h3 id="顶层仓库"><a href="#顶层仓库" class="headerlink" title="顶层仓库"></a>顶层仓库</h3><p>只包含仓库名 即 ubuntu  </p>
<h3 id="下载latest标签镜像"><a href="#下载latest标签镜像" class="headerlink" title="下载latest标签镜像"></a>下载latest标签镜像</h3><p>如果没有指定标签 那么下载 latest标签镜像<br>也就是最后一个版本  </p>
<h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><p><code>sudo docker search</code>  </p>
<p><img src="/2019/11/24/第一本docker读书笔记/%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F.jpg" alt="查找镜像"></p>
<p>STARS     受欢迎程度<br>OFFICIAL  是否官方<br>AUTOMATED 是由Docker Hub自动构建流程创建的  </p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><ol>
<li>使用 docker commit 命令</li>
<li>使用dokcer build 和 Dockerfile文件</li>
</ol>
<p>推荐使用 Dockerfile文件来创建  </p>
<h4 id="登录到docker-hub"><a href="#登录到docker-hub" class="headerlink" title="登录到docker hub"></a>登录到docker hub</h4><p><code>sudo docker login</code></p>
<p>这样就可以获取和上传自己的镜像了  </p>
<h4 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h4><p>对容器进行修改操作后  </p>
<p><code>sudo docker commit 容器id 用户名/仓库名:标签</code><br>当然后面可以增加标签<br>commit只是提交了与原始的差异部分<br>返回一个新的镜像id名<br>commit的其他选项参数:  </p>
<p>-m 提交的信息<br>-a 作者的信息</p>
<h2 id="使用Dokcerfile创建镜像"><a href="#使用Dokcerfile创建镜像" class="headerlink" title="使用Dokcerfile创建镜像"></a>使用Dokcerfile创建镜像</h2><p>使用DSL语法的指令来构建一个Docker镜像  </p>
<p>这里按书里来的话会有问题 镜像会一直启动失败<br>需要修改 /etc/nginx/sites-available/default 的配置为 listen 80<br>替换过去才能成功启动  </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> recar <span class="string">"reacr@admin.com"</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'Hi I am  in your container'</span> \</span></span><br><span class="line"><span class="bash">    &gt; /var/www/html/index.html</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./default /etc/nginx/sites-available/default</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">	<span class="comment"># listen 80 default_server;</span></span><br><span class="line">	<span class="comment">#listen [::]:80 default_server;</span></span><br></pre></td></tr></table></figure>

<p>每条指令都的大写<br>每条指令都会创建一个新的镜像层并对镜像进行提交<br><code>#</code> 开头是注释<br>第一条指令一定是 FROM<br>因为是基于这个镜像的容器进行操作<br>MAINTAINER 指定作者是谁<br>EXPOSE 告诉Docker该容器内的应用程序将会使用容器的指定端口<br>Docker并不会自动打开该端口 而是需要用户在使用 docker run 运行容器的时候指定打开哪些端口  </p>
<p>EXPOSE 指令也帮助多个容器连接  </p>
<p>构建镜像<br><code>sudo docker build -t &quot;用户名/仓库名:标签&quot; .</code><br>执行的命令结果会在控制台输出的  </p>
<p>这里是指定的当前目录下的Dockerfile文件构建<br>还可以指定 git仓库的源地址来指定  </p>
<p>构建成功输出 镜像id</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Removing intermediate container 8eb81634bad7</span><br><span class="line">Successfully built 88010c9a82e0</span><br></pre></td></tr></table></figure>

<h3 id="如果构建失败"><a href="#如果构建失败" class="headerlink" title="如果构建失败"></a>如果构建失败</h3><p>还是可以 dokcer run 已经构建完的镜像id 因为每次都commit了<br>来调试问题  </p>
<h3 id="Dockerfile和构建缓存"><a href="#Dockerfile和构建缓存" class="headerlink" title="Dockerfile和构建缓存"></a>Dockerfile和构建缓存</h3><p>每一步构建都会提交镜像<br>会将之前的镜像层看作缓存 做过的就直接用了<br>但是我们需要不使用缓存 比如 apt-get update<br>这样指定: <code>sudo docker build --no-cache</code></p>
<h3 id="基于构建缓存的Dockerfile模板"><a href="#基于构建缓存的Dockerfile模板" class="headerlink" title="基于构建缓存的Dockerfile模板"></a>基于构建缓存的Dockerfile模板</h3><p>实现简单的Dokcerfile模板<br>也就是一些前置的操作保证相同 那么就会使用缓存了  </p>
<p>可以这样  </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> recar <span class="string">"reacr@admin.com"</span></span><br><span class="line"><span class="keyword">ENV</span> REFRESHED_AT <span class="number">2019</span>-<span class="number">11</span>-<span class="number">18</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -qq update</span></span><br></pre></td></tr></table></figure>

<p>前面到ENV都是一样的<br>我们只需要每次都修改设置的环境变量也就是模板最后的更新时间<br>然后从这之后都不会使用缓存了 也就是update会正常执行而不是使用缓存了  </p>
<h3 id="查看构建的历史log"><a href="#查看构建的历史log" class="headerlink" title="查看构建的历史log"></a>查看构建的历史log</h3><p><code>sudo docker history 镜像id</code></p>
<p><img src="/2019/11/24/第一本docker读书笔记/sudo_docker_history.jpg" alt="sudo_docker_history"></p>
<h3 id="运行构建的镜像"><a href="#运行构建的镜像" class="headerlink" title="运行构建的镜像"></a>运行构建的镜像</h3><p><code>sudo docker run -d -p 80 --name static_web nginx:test3 nginx -g &quot;daemon off;&quot;</code></p>
<h3 id="通过-P-参数将-expose-的端口随机映射"><a href="#通过-P-参数将-expose-的端口随机映射" class="headerlink" title="通过-P 参数将 expose 的端口随机映射"></a>通过-P 参数将 expose 的端口随机映射</h3><p><code>sudo docker run -d -P --name static_web</code>  </p>
<p>这里的-P 注意是大写P会随机将 expose的端口映射出去  </p>
<h3 id="Dockerfile-CMD"><a href="#Dockerfile-CMD" class="headerlink" title="Dockerfile CMD"></a>Dockerfile CMD</h3><p>用于指定一个容器启动时要运行的命令  类似 RUN 但是RUN 是指定镜像被构建时运行的命令<br>CMD 是容器被启动后要运行命令  </p>
<p><code>CMD [&quot;bin/bash&quot;, &quot;-l&quot;]</code><br>将要执行的命令和参数放到数组格式中  </p>
<p><strong>docker run命令可以覆盖 CMD指令</strong>  </p>
<p>这样构建就可以直接启动了<br>要注意 CMD 的写法 不然会报错  </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version: 0.0.1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> recar <span class="string">"reacr@admin.com"</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'Hi I am  in your container'</span> \</span></span><br><span class="line"><span class="bash">    &gt; /var/www/html/index.html</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./default /etc/nginx/sites-available/default</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建镜像:<br><code>sudo docker build -t nginx:test4 .</code></p>
<p>运行:<br><code>sudo docker run -d -p 80 --name static_web nginx:test4</code></p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>这个是会接收 run 传入的参数进行执行<br>如果  </p>
<p><code>ENTRYPOINT [&quot;nginx&quot;]</code>  </p>
<p>然后在run的时候进行传递参数来控制<br><code>sudo docker run -d -p 80 --name static_web nginx:test4 -g  &quot;daemon off;&quot;</code></p>
<p>这样来启动  </p>
<p>而如果是CMD 的话会被run覆盖  </p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>WORKDIR 指令用来在从镜像创建一个新容器时 在容器内部设置一个工作目录  </p>
<p>ENTRYPOINT 和CMD 会在这个目录下执行  </p>
<p>即可以通过切换目录来执行一些命令  </p>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV 指令用来再镜像构建过程中设置环境变量  </p>
<p><code>ENV 环境变量名 值</code>  </p>
<p>还可以通过 run的 -e来添加环境变量  </p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>USER 指令用来指定该镜像会以什么样的用户去运行  </p>
<p>docker run -u 也可以指定  </p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>VOLUME 指令用来向基于镜像创建的容器添加卷<br>一个卷可以存在于一个或者多个容器内的特定的目录  </p>
<p><code>VOLUME [&quot;/data&quot;]</code>  </p>
<p>这样加上的话就会把 容器内的 /data 写到宿主机的一个位置 这个位置需要 docker inspect去查看 相当于是匿名的  </p>
<p>也可以 docker -run -v /data/mydata:/data 这样来指定挂载到宿主机的存储位置  </p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>ADD指令用来将构建环境下的文件和目录复制到镜像中  </p>
<p><code>ADD (源文件)Dockerfile同级目录下 镜像文件</code><br>源文件也可以是个url </p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>COPY 只能 把本地的文件拷贝到容器镜像中<br>但是ADD 还可以解压  </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br></pre></td></tr></table></figure>

<p><strong>COPY 和 ADD 命令不能拷贝Dockerfile 目录下之外的本地文件</strong><br>不然会报错 找不到这个文件  </p>
<h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>STOPSIGNAL 指令用来设置停止容器发送什么系统调用信号给容器  </p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>用来在 docker build的时候传递给正在运行的一些变量<br>使用  <code>sudo docker build --build-arg &lt;varname&gt;=&lt;value&gt;</code><br>预定义的一些变量<br>比如下面的代理  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP_PROXY</span><br><span class="line">http_proxy</span><br><span class="line">HTTPS_PROXY</span><br><span class="line">https_proxy</span><br><span class="line">FTP_PROXY</span><br><span class="line">ftp_proxy</span><br><span class="line">NO_PROXY</span><br><span class="line">no_proxy</span><br></pre></td></tr></table></figure>

<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD 指令能为 镜像添加触发器 当一个镜像被用作其他镜像的基础镜像的时候 该镜像中的额触发器将会执行  </p>
<p>可以通过 docker inspect 来查看</p>
<p><code>ONBUILD ADD . /var/www/</code></p>
<p>加了这个以后 被用作基础镜像的时候就会执行这个 将当前目录的文件都复制到 镜像的 <code>/var/www/</code> 下  </p>
<p>只能继承一次 孙镜像不会执行  </p>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p><code>sudo docker push 用户名/仓库:标签</code>  </p>
<p>前提是 <code>sudo docker loging</code> 过  </p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><code>sudo docker rmi 镜像名</code>  </p>
<h3 id="可以通过-docker的-registry-搭建私服"><a href="#可以通过-docker的-registry-搭建私服" class="headerlink" title="可以通过 docker的 registry 搭建私服"></a>可以通过 docker的 registry 搭建私服</h3><p>构建一些私密的环境  </p>
<h3 id="设置映射的卷为只读模式"><a href="#设置映射的卷为只读模式" class="headerlink" title="设置映射的卷为只读模式"></a>设置映射的卷为只读模式</h3><p><code>sudo docker -v 本地:/容器路径:ro</code><br>ro为只读 rw为读写 默认是rw读写  </p>
<h2 id="连接两个容器"><a href="#连接两个容器" class="headerlink" title="连接两个容器"></a>连接两个容器</h2><p>Docker Networking 可以将容器连接到不同宿主机上的容器上<br>可以在无须更新连接的情况下 对停止 启动或者重启容器<br>不必事先创建容器再去连接他 也不必关心容器的连接顺序  </p>
<h3 id="Docker-内部连网"><a href="#Docker-内部连网" class="headerlink" title="Docker 内部连网"></a>Docker 内部连网</h3><p>会有个虚拟网卡 docker0  </p>
<p>虚拟的以太桥 <code>172.17.x.x</code><br>用于连接宿主机和容器  </p>
<p>docker0也就是容器的网关  </p>
<h3 id="Docker-Networking"><a href="#Docker-Networking" class="headerlink" title="Docker Networking"></a>Docker Networking</h3><p>这里事例是连接web服务与redis服务 连通两个容器  </p>
<p>先创建私有网络  </p>
<p><code>sudo docker network create app</code>  </p>
<p>这样创建了一个桥接网络 命名为app  </p>
<p><img src="/2019/11/24/第一本docker读书笔记/docker_network_create.jpg" alt="docker_network_create"></p>
<p>并且 ifconfig也能看到这个虚拟网卡  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">br-2be9811d85f5 Link encap:以太网  硬件地址 02:42:a5:59:31:ab  </span><br><span class="line">          inet 地址:172.18.0.1  广播:172.18.255.255  掩码:255.255.0.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  跃点数:1</span><br><span class="line">          接收数据包:0 错误:0 丢弃:0 过载:0 帧数:0</span><br><span class="line">          发送数据包:0 错误:0 丢弃:0 过载:0 载波:0</span><br><span class="line">          碰撞:0 发送队列长度:0 </span><br><span class="line">          接收字节:0 (0.0 B)  发送字节:0 (0.0 B)</span><br></pre></td></tr></table></figure>

<p>可通过 <code>sudo docker network ls</code> 查看docker网络  </p>
<p>启动容器的时候 指定 接入这个网络 只要 run的时候增加 <code>--net=app</code>  </p>
<p><code>sudo docker run -it -d -p 6666:80 --net=app --name net_test 0976afc45249 /bin/bash</code>  </p>
<p>启动后再次查看 app网络  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"Containers": &#123;</span><br><span class="line">	"01cb8f1027ef78064e5617e71c053d1542849514e31fb0fbecf7aee2994583a7": &#123;</span><br><span class="line">		"Name": "net_test",</span><br><span class="line">		"EndpointID": "1791324ccabfd6dca652e7616a41e7a01ce9c18bda9a5a2833bfcf21a47fa194",</span><br><span class="line">		"MacAddress": "02:42:ac:12:00:02",</span><br><span class="line">		"IPv4Address": "172.18.0.2/16",</span><br><span class="line">		"IPv6Address": ""</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>重启之前的容器加入到这个网络中  </p>
<p><code>sudo docker run -it -d -p 7777:80 --net=app --name sqli 0976afc45249 /bin/bash</code>  </p>
<p>查看 hosts  </p>
<p><img src="/2019/11/24/第一本docker读书笔记/etc_hosts.jpg" alt="etc_hosts">  </p>
<p>可以看到这里的直接ping 容器名就解析到这个ip了  </p>
<p>写代码的时候做配置的时候都可以直接写容器名字  </p>
<h3 id="可以不重启容器直接将容器容器添加到网络中"><a href="#可以不重启容器直接将容器容器添加到网络中" class="headerlink" title="可以不重启容器直接将容器容器添加到网络中"></a>可以不重启容器直接将容器容器添加到网络中</h3><p><code>sudo docker network connect 网络名 容器名</code>  </p>
<h3 id="断开网络与容器"><a href="#断开网络与容器" class="headerlink" title="断开网络与容器"></a>断开网络与容器</h3><p><code>sudo docker network disconnect 网络名 容器名</code>  </p>
<h2 id="通过-docker链接连接容器"><a href="#通过-docker链接连接容器" class="headerlink" title="通过 docker链接连接容器"></a>通过 docker链接连接容器</h2><p>这种时候复现快速使用的时候<br>容器的名字是唯一的<br>正常启动<br><code>sudo docker run -d --name redis xxx</code>  </p>
<p>另一个容器连接  </p>
<p><code>sudo dokcer run -p xx --name xx --link redis:db -it -d 容器 /bin/bash</code></p>
<p>通过 <code>--link</code> 连接  </p>
<p><code>--link 要连接的容器名: 别名</code>  </p>
<p>之后可以在这个容器中看到别名 db的相关环境变量  端口协议等<br>而且这里的redis服务都没有对外开放端口<br>只有 –link的才能连接到这个容器  </p>
<p>还可以在容器启动的时候添加 hosts信息  </p>
<p><code>--add-host=name:ip</code>  </p>
<h3 id="特权模式-–privileged"><a href="#特权模式-–privileged" class="headerlink" title="特权模式 –privileged"></a>特权模式 –privileged</h3><p>run的时候添加这个参数可以 允许以其宿主机具有的(几乎)所有能力来运行容器<br>包括一些内核特性和设备访问 会有安全风险 </p>
<h3 id="容器进程运行完成后-删除容器"><a href="#容器进程运行完成后-删除容器" class="headerlink" title="容器进程运行完成后 删除容器"></a>容器进程运行完成后 删除容器</h3><p><code>sudo docker run -it --rm</code>  </p>
<h3 id="授权一个容器访问另一个容器的数据卷"><a href="#授权一个容器访问另一个容器的数据卷" class="headerlink" title="授权一个容器访问另一个容器的数据卷"></a>授权一个容器访问另一个容器的数据卷</h3><p>如果要授权一个容器访问另一个容器的Volume,我们可以使用 <code>--volumes-from</code>参数来执行docker run </p>
<p><code>sudo docker run --volumes-from 另一个容器的 Volume</code>  </p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p>最简单的可以通过 pip安装<br><code>sudo pip install -U docker-compose</code></p>
<p>使用 docker-compose 部署应用<br>需要 <code>docker-compose.yml</code>  </p>
<p>写完 yml后 执行 docker-componse up 就会使用指定的参数启动 容器 并将所有的日志合并到一起  </p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">	<span class="attr">image:</span> <span class="string">镜像</span></span><br><span class="line">	<span class="attr">command:</span> <span class="string">执行命令</span></span><br><span class="line">	<span class="attr">ports:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">	<span class="attr">volumes:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">.:/compose</span></span><br><span class="line">	<span class="attr">links:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">	<span class="string">第一本docker读书笔记:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>

<p>必须在 <code>docker-compose.yml</code> 的目录执行执行大多数 命令  </p>
<p>如果后台执行就 -d  </p>
<p><code>sudo docker-compose up -d</code>  </p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p><code>sudo docker-compose logs</code>  </p>
<h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><p><code>sudo docker-compose stop</code>  </p>
<h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><p><code>sudo docker-compose ps</code>  </p>
<p>可以使用这个快速构建一个大型的环境  </p>
<h2 id="Dokcer-Swarm"><a href="#Dokcer-Swarm" class="headerlink" title="Dokcer Swarm"></a>Dokcer Swarm</h2><p>是原生的 Dokcer集群管理工具<br>他将多台Docker主机作为一个集群 并在集群级别上以标准Docker API 的形式提供服务<br>对外来说 Swarm集群只是相当于一台普通的Docker主机而已  </p>
<p>要想支持 Swarm Docker有一个最低的版本 必须在 1.4.0以上<br>并且需要都是同一个版本的dokcer 不能混合搭配不同的版本<br>Swarm 和 Kubernetes 比较类似，但是更加轻，具有的功能也较 kubernetes 更少一些。  </p>
<p>安装的话可以直接从 dockerhub拉取  </p>
<p><code>sudo docker pull swarm</code>  </p>
<p>使用默认的DockerHUb作为集群发现服务创建 Swarm集群  </p>
<h3 id="创建Swarm集群"><a href="#创建Swarm集群" class="headerlink" title="创建Swarm集群"></a>创建Swarm集群</h3><p><code>sudo dokcer run swarm create</code>  </p>
<p>会返回一个id 我们利用这个id向集群中添加节点  </p>
<p>运行swarm代理  </p>
<p><code>sudo docker run -d swarm join --addr=本机ip:2375 token://上面返回的id</code>  </p>
<h3 id="列出Swarm节点"><a href="#列出Swarm节点" class="headerlink" title="列出Swarm节点"></a>列出Swarm节点</h3><p><code>sudo docker run --rm swarm list token://上面id</code>  </p>
<h3 id="启动-Swarm集群管理者"><a href="#启动-Swarm集群管理者" class="headerlink" title="启动 Swarm集群管理者"></a>启动 Swarm集群管理者</h3><p><code>sudo docker run -d -p 2380:2375 searm manage token://上面id</code>  </p>
<h3 id="在Swarm中运行-info命令"><a href="#在Swarm中运行-info命令" class="headerlink" title="在Swarm中运行 info命令"></a>在Swarm中运行 info命令</h3><p><code>sudo dockerm -H tcp://localhost:2380 info</code>  </p>
<p>会输出所有节点的信息<br>tcp://localhost:2380 这个是管理者的地址  </p>
<p>这个更深入的了解链接  <a href="http://c.biancheng.net/view/3178.html" target="_blank" rel="noopener">http://c.biancheng.net/view/3178.html</a>  </p>
<p>这个后续可以再深入了解下还有k8s  </p>
<h2 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h2><p>有与存储镜像 Registry的<br>与DockerHub的<br>与Docker守护进程的<br>三种API<br>主要是与Dokcer守护进程通信<br>都是RESTful风格的  </p>
<p>Docker守护进程会绑定到 unix://var/run/docker.sock  </p>
<p>本机请求获取info信息  </p>
<p><code>echo -e &quot;GET /info HTTP/1.0\r\n&quot; | sudo nc -U /var/run/docker.sock</code>  </p>
<p>会返回json格式的info信息数据  </p>
<h3 id="连接到远程Docker守护进程"><a href="#连接到远程Docker守护进程" class="headerlink" title="连接到远程Docker守护进程"></a>连接到远程Docker守护进程</h3><p><code>sudo docker -H ip:2375 info</code>  </p>
<p>也就是说可以通过这个api来获取信息和执行各种操作命令  </p>
<h3 id="开启这个API"><a href="#开启这个API" class="headerlink" title="开启这个API"></a>开启这个API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先是怎么配置远程访问的API：</span></span><br><span class="line">sudo vim /etc/default/docker</span><br><span class="line"><span class="comment"># 加入下面一行</span></span><br><span class="line">DOCKER_OPTS=<span class="string">"-H tcp://0.0.0.0:2375"</span></span><br><span class="line">重启docker即可：</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>这样直接是不安全的 可以配置TLS CA证书 秘钥来保证安全</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这本书只是入门书籍 梳理串联下知识点 且版本有些老 只能用作参考  </p>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/17/redis实战读书笔记-五/" rel="next" title="redis实战读书笔记(五)">
                <i class="fa fa-chevron-left"></i> redis实战读书笔记(五)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/09/Dsxs源码简单分析/" rel="prev" title="Dsxs源码简单分析">
                Dsxs源码简单分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Recar">
  
  <p class="site-author-name" itemprop="name">Recar</p>
  <div class="site-description motion-element" itemprop="description">年轻人就应该多读源码多读书</div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    

    
      
      
      <div class="site-state-item site-state-tags">
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>













          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一本docker"><span class="nav-number">1.</span> <span class="nav-text">第一本docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装docker"><span class="nav-number">1.1.</span> <span class="nav-text">安装docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-与ufw"><span class="nav-number">1.1.1.</span> <span class="nav-text">docker 与ufw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-一键安装脚本"><span class="nav-number">1.1.2.</span> <span class="nav-text">docker 一键安装脚本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动容器"><span class="nav-number">1.2.</span> <span class="nav-text">启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取最后一个运行的容器-无论停止还是运行"><span class="nav-number">1.2.1.</span> <span class="nav-text">获取最后一个运行的容器 无论停止还是运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attach命令是附着到容器的会话上"><span class="nav-number">1.2.2.</span> <span class="nav-text">attach命令是附着到容器的会话上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取容器的日志"><span class="nav-number">1.2.3.</span> <span class="nav-text">获取容器的日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看容器内的进程"><span class="nav-number">1.2.4.</span> <span class="nav-text">查看容器内的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看容器cpu内容io等实时信息"><span class="nav-number">1.2.5.</span> <span class="nav-text">查看容器cpu内容io等实时信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在容器中运行后台任务"><span class="nav-number">1.2.6.</span> <span class="nav-text">在容器中运行后台任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看最后x个容器"><span class="nav-number">1.2.7.</span> <span class="nav-text">查看最后x个容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动重启容器"><span class="nav-number">1.2.8.</span> <span class="nav-text">自动重启容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取容器更多的信息"><span class="nav-number">1.2.9.</span> <span class="nav-text">获取容器更多的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取容器运行状态"><span class="nav-number">1.2.10.</span> <span class="nav-text">获取容器运行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除容器"><span class="nav-number">1.2.11.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除所有容器"><span class="nav-number">1.2.12.</span> <span class="nav-text">删除所有容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像"><span class="nav-number">1.3.</span> <span class="nav-text">镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拉取镜像"><span class="nav-number">1.3.1.</span> <span class="nav-text">拉取镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看当前镜像"><span class="nav-number">1.3.2.</span> <span class="nav-text">查看当前镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户仓库"><span class="nav-number">1.3.3.</span> <span class="nav-text">用户仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顶层仓库"><span class="nav-number">1.3.4.</span> <span class="nav-text">顶层仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载latest标签镜像"><span class="nav-number">1.3.5.</span> <span class="nav-text">下载latest标签镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找镜像"><span class="nav-number">1.3.6.</span> <span class="nav-text">查找镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建镜像"><span class="nav-number">1.3.7.</span> <span class="nav-text">构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#登录到docker-hub"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">登录到docker hub</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-commit"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">docker commit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Dokcerfile创建镜像"><span class="nav-number">1.4.</span> <span class="nav-text">使用Dokcerfile创建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如果构建失败"><span class="nav-number">1.4.1.</span> <span class="nav-text">如果构建失败</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile和构建缓存"><span class="nav-number">1.4.2.</span> <span class="nav-text">Dockerfile和构建缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于构建缓存的Dockerfile模板"><span class="nav-number">1.4.3.</span> <span class="nav-text">基于构建缓存的Dockerfile模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看构建的历史log"><span class="nav-number">1.4.4.</span> <span class="nav-text">查看构建的历史log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行构建的镜像"><span class="nav-number">1.4.5.</span> <span class="nav-text">运行构建的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-P-参数将-expose-的端口随机映射"><span class="nav-number">1.4.6.</span> <span class="nav-text">通过-P 参数将 expose 的端口随机映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-CMD"><span class="nav-number">1.4.7.</span> <span class="nav-text">Dockerfile CMD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">1.4.8.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WORKDIR"><span class="nav-number">1.4.9.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENV"><span class="nav-number">1.4.10.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USER"><span class="nav-number">1.4.11.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VOLUME"><span class="nav-number">1.4.12.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADD"><span class="nav-number">1.4.13.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#COPY"><span class="nav-number">1.4.14.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STOPSIGNAL"><span class="nav-number">1.4.15.</span> <span class="nav-text">STOPSIGNAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARG"><span class="nav-number">1.4.16.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ONBUILD"><span class="nav-number">1.4.17.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送镜像"><span class="nav-number">1.4.18.</span> <span class="nav-text">推送镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除镜像"><span class="nav-number">1.4.19.</span> <span class="nav-text">删除镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以通过-docker的-registry-搭建私服"><span class="nav-number">1.4.20.</span> <span class="nav-text">可以通过 docker的 registry 搭建私服</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置映射的卷为只读模式"><span class="nav-number">1.4.21.</span> <span class="nav-text">设置映射的卷为只读模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接两个容器"><span class="nav-number">1.5.</span> <span class="nav-text">连接两个容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-内部连网"><span class="nav-number">1.5.1.</span> <span class="nav-text">Docker 内部连网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Networking"><span class="nav-number">1.5.2.</span> <span class="nav-text">Docker Networking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以不重启容器直接将容器容器添加到网络中"><span class="nav-number">1.5.3.</span> <span class="nav-text">可以不重启容器直接将容器容器添加到网络中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断开网络与容器"><span class="nav-number">1.5.4.</span> <span class="nav-text">断开网络与容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-docker链接连接容器"><span class="nav-number">1.6.</span> <span class="nav-text">通过 docker链接连接容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特权模式-–privileged"><span class="nav-number">1.6.1.</span> <span class="nav-text">特权模式 –privileged</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器进程运行完成后-删除容器"><span class="nav-number">1.6.2.</span> <span class="nav-text">容器进程运行完成后 删除容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#授权一个容器访问另一个容器的数据卷"><span class="nav-number">1.6.3.</span> <span class="nav-text">授权一个容器访问另一个容器的数据卷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#docker-compose"><span class="nav-number">1.7.</span> <span class="nav-text">docker compose</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看日志"><span class="nav-number">1.7.1.</span> <span class="nav-text">查看日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#停止服务"><span class="nav-number">1.7.2.</span> <span class="nav-text">停止服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看服务"><span class="nav-number">1.7.3.</span> <span class="nav-text">查看服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dokcer-Swarm"><span class="nav-number">1.8.</span> <span class="nav-text">Dokcer Swarm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Swarm集群"><span class="nav-number">1.8.1.</span> <span class="nav-text">创建Swarm集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列出Swarm节点"><span class="nav-number">1.8.2.</span> <span class="nav-text">列出Swarm节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动-Swarm集群管理者"><span class="nav-number">1.8.3.</span> <span class="nav-text">启动 Swarm集群管理者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在Swarm中运行-info命令"><span class="nav-number">1.8.4.</span> <span class="nav-text">在Swarm中运行 info命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-API"><span class="nav-number">1.9.</span> <span class="nav-text">Docker API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#连接到远程Docker守护进程"><span class="nav-number">1.9.1.</span> <span class="nav-text">连接到远程Docker守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开启这个API"><span class="nav-number">1.9.2.</span> <span class="nav-text">开启这个API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.10.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Recar</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    

  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
















  
  









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  


  


























<script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script>








  

</body>
</html>
